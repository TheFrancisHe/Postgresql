- Combining Multiple Indexes

condition（查询条件）里有 and 或者 or ，并且 and 和 or 相关的列都创建了索引，那么就可以走 bitmap index的 合并。

相当于，先对索引取出数据， 这些数据有tuple id （ctid），对这些ctid做 bitmap，最后传导给

- 代码所在路径：
src/backend/executor

- 哦，对了，这篇博客有利于学习 bitmap index （oracle数据库的bitmap index ）

http://www.cnblogs.com/LBSer/p/3322630.html

通读完毕后，可以对 bitmap 串 ，bitmap index 应用场景有基本的认识。

>这个时候有人会说使用位图索引，因为busy只有两个值。好，我们使用位图索引索引busy字段！假设用户A使用update更新某个机器的busy值，
>比如update table set table.busy=1 where rowid=100;，但还没有commit，而用户B也使用update更新另一个机器的busy值，update table set table.busy=1 where rowid=12; 这个时候用户B怎么也更新不了，需要等待用户A commit。
>原因：用户A更新了某个机器的busy值为1，会导致所有busy为1的机器的位图向量发生改变，因此数据库会将busy＝1的所有行锁定，只有commit之后才解锁。

最后一段话，给我造成了些困扰，现在明白了，通过德哥的这篇文章：

https://github.com/digoal/blog/blob/master/201705/20170512_01.md

>不适合频繁的更新，因为更新可能带来行迁移，以及VALUE的变化。

>如果是行迁移，需要更新整个bitmap串。

>如果是VALUE变化，则需要修改整个与变化相关的VALUE的BIT串。(疑问： update的话，必定发生行迁移，德哥的意思难道是也有不发生行迁移的update么？)

大意为： 如果发生行迁移，所有tuple的排列顺序变了，自然而然，所有bit串里的bit的位置会发生变化--

        我描述的不详细，回头用图完善下这里。
        
- 留个问题： 关于 heap table 和 行迁移， 我的了解仅仅趋于表面，之后会深入的,

>堆表（heap table）数据插入时时存储位置是随机的，主要是数据库内部块的空闲情况决定，获取数据是按照命中率计算，全表扫表时不见得先插入的数据先查到。

>对了bitmap index 在greenplum里支持，在PG里不支持，但是有其他形式。

```
select * from table where col = a and col = b and col2=xxx;        
-- a,b的bit串进行BITAND的操作，然后再和col2=xxx的BIT进行BITAND操作，返回BIT位为1的，使用bitmap function返回行号，取记录。    

关于这里的bitand 操作，参见百度百科

https://baike.baidu.com/item/bitand/10610292?fr=aladdin
      
select count(*) from table where col = a and col = b and col2=xxx;        
-- a,b的bit串进行BITAND的操作，然后再和col2=xxx的BIT进行BITAND操作，返回BIT位为1的，使用bitmap function返回行号，取记录，算count(*)。
```

-关于PG里的bitmap scan，可以参考德哥这篇博客：

https://github.com/digoal/blog/blob/master/201702/20170221_02.md








  
  

