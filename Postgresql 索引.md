- 使用索引的好处

利用索引进行排序减少CPU开销

//如果一个表有100w条记录，没索引的话，就要进行顺序检索了。
//排序，没有索引的话，把数据全部取出来，然后做排序操作。 有索引的话，通过索引进行排序。

加速带条件的查询, 删除, 更新

加速JOIN操作

加速外键约束更新和删除操作

加速唯一值约束, 排他约束

- 索引带来的弊端

索引随着表的记录块的变迁需要更新, 因此会对这类操作带来一定的性能影响. (块不变更的情况下触发HOT特性, 可
以不需要更新索引)

仅仅是在行更新之后，还在原来的数据块里，同时更新的字段不是索引字段，这是不需要更新索引的。
对于写多读少会是累赘。


- 使用索引的注意事项

正常创建索引时, 会阻断除查询以外的其他操作.（insert update delete）

创建索引的时候，如果DML非常频繁的话，建议使用CONCURRENTLY。

使用并行CONCURRENTLY 选项后, 可以允许同时对表的DML操作, 但是对于频繁DML的表, 这种创建索引的时间
非常长.

//因为频繁的DML，原来的行可能会删掉了或者改变了，所以索引不停的要进行合并，，将产生的变更合并到索引里


某些索引不记录WAL, 所以如果有利于WAL进行数据恢复的情况(如crash recovery, 流复制, warm standby等), 这类
索引在使用前需要重建. (HASH 索引)

因为wal日志里没有这些索引的记录。


### 索引类型
- 索引类型

根据不同的索引算法, PostgreSQL的算法分为 B-tree, Hash, GiST, SP-GiST, GIN

select amname from pg_am;

- 索引应用场景

PostgreSQL不同的索引类别支持的索引访问操作符也有区别, 以下为不同的索引类型对应的系统默认的索引策略

Btree

除了支持以下查询外，同时还支持前导模糊查询(like ‘xxx%’ 或 ~ ‘^xxx’), 忽略大小写字符前导模糊查询(ILIKE ‘xxx%’ 或 ~* ‘^xxx’)

<

<=

=

>=

>


Hash

=

Gin

支持多值列的索引, 例如数组类型, 全文检索类型, 例如以下为一维数组类型对应的GIN索引已实现的访问策略操作符

<@ -- 被包含 array[1,2,3] <@ array[2,3,1]

@> -- 包含 array[1,2,3] @> array[2]

= -- 相等 array[1,2,3] = array[1,2,3]

&& -- 相交 array[1,2,3] && array[2]

Gist

并不是单类的索引, 可以认为它是一种索引框架, 支持许多不同的索引策略(operator class),

例如二维几何类型的以下操作符支持通过Gist索引访问
```
<< -- 严格在左侧, 例如circle '((0,0),1)' << circle '((5,0),1)'
&< -- 表示左边的平面体不会扩展到超过右边的平面体的右边. 例如box '((0,0),(1,1))' &< box '((0,0),(2,2))'
&> -- 表示左边的平面体不会扩展到超过右边的平面体的左边. 例如box '((0,0),(3,3))' &> box '((0,0),(2,2))'
>> -- 严格在右
<<| -- 严格在下
&<| -- 不会扩展到超出上面
|&> -- 不会扩展到超出下面
|>> -- 严格在上
@> -- 包含
<@ -- 被包含
~= -- 相同
&& -- 相交
```
http://www.postgresql.org/docs/9.3/static/functions-geometry.html

除此之外 , gist索引还支持近邻排序. 例如
```
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
```
另外contrib中也提供了一些gist索引策略.

Sp-Gist

与gist类似, 也是一种索引框架, 支持基于磁盘存储的非平衡数据结构, 如四叉树, k-d树, radix树.

例如二维的point类型, Sp-gist索引支持的操作符如下

```
<<
>>
~=
<@

//左边的圆在右边这个圆的平面的下面。
<^ -- 在下面, circle '((0,0),1)' <^ circle '((0,5),1)'


//左边的圆在右边这个圆的平面的上面。
>^ -- 在上面, circle '((0,5),1)' >^ circle '((0,0),1)'

```

### PostgreSQL 索引使用场景举例
- 利用索引进行排序减少CPU开销






